{"version":3,"sources":["../index.ts"],"names":[],"mappings":";AAAA,SAAS,KAAK,cAAc;AAWrB,IAAM,aAAa,CAAC,KAAe,YAAY,MAAM;AAC1D,QAAM,SAAS,CAAC;AAChB,MAAI,MAAM;AACV,WAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACnC,UAAM,MAAM,IAAI,CAAC;AACjB,WAAO,KAAK,GAAG;AAAA,EACjB;AACA,SAAO,OAAO,IAAI,CAAC,QAAQ,OAAO,KAAK,SAAS,CAAC;AACnD;AAYO,IAAM,aAAa,CACxB,KACA,OACA,aACA,OAAyB,YACtB;AAEH,MAAI,SAAS;AAAS,QAAI,QAAQ,KAAK;AAAA,WAC9B,SAAS;AAAQ,QAAI,KAAK,KAAK;AAExC,MAAI,IAAI,SAAS,aAAa;AAC5B,QAAI,SAAS;AAAS,UAAI,IAAI;AAAA,aACrB,SAAS;AAAQ,UAAI,MAAM;AAAA,EACtC;AACA,SAAO;AACT;AAQO,IAAM,aAAa,CACxB,GACA,OACQ;AACR,MAAI,IAAI,GAAG;AACT,WAAO,MAAM,CAAC,EAAE,KAAK,IAAI,EAAE,IAAI,EAAE;AAAA,EACnC;AACA,QAAM,IAAI,MAAM,2CAA2C;AAC7D;AAOO,IAAM,oBAAoB,CAAC,QAA4B;AAC5D,QAAM,SAAS,CAAC;AAChB,WAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACnC,QAAI,IAAI,CAAC,MAAM;AAAG,aAAO,KAAK,CAAC;AAAA,EACjC;AACA,SAAO;AACT;AAYO,IAAM,mBAAmB,CAC9B,UACA,WACA,MACG;AACH,MAAI,SAAS,WAAW,KAAK,UAAU,WAAW;AAChD,UAAM,IAAI,MAAM,4CAA4C;AAC9D,MAAI,SAAS,WAAW,UAAU;AAChC,UAAM,IAAI,MAAM,yCAAyC;AAC3D,SAAO,MAAM,SAAS,MAAM,EACzB,KAAK,CAAC,EACN,IAAI,CAAC,GAAG,MAAM;AACb,WAAO,IAAI,SAAS,CAAC,GAAG,UAAU,CAAC,GAAG,CAAC;AAAA,EACzC,CAAC;AACL;AAOO,IAAM,WAAW,CAAC,QAAkB,IAAI,MAAM,CAAC,OAAO,OAAO,CAAC;AAO9D,IAAM,YAAY,CAAC,QAAkB,IAAI,MAAM,CAAC,OAAO,OAAO,CAAC;AAO/D,IAAM,WAAW,CAAC,QAAkB,IAAI,KAAK,CAAC,OAAO,OAAO,CAAC;AAO7D,IAAM,YAAY,CAAC,QAAkB,IAAI,KAAK,CAAC,OAAO,OAAO,CAAC;AAQ9D,IAAM,gBAAgB,CAAI,KAA2B,SAAmB;AAC7E,SAAO,KAAK,IAAI,CAAC,QAAQ,IAAI,GAAG,CAAC;AACnC;AAUO,IAAM,uBAAuB,CAClC,KACA,WACG;AACH,SAAO,MAAM,IAAI,MAAM,EACpB,KAAK,IAAI,EACT,IAAI,CAAC,GAAG,MAAM;AACb,QAAI,IAAI,CAAC,EAAE,MAAM,MAAM,QAAW;AAChC,aAAO,IAAI,CAAC,EAAE,MAAM;AAAA,IACtB,OAAO;AACL,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AACL","sourcesContent":["import { mix, roundF } from \"@daeinc/math\";\n\n/**\n * accumulate array values. ex. [50,50,50] => [50,100,150]\n * use original value while summing, but return value will be rounded\n *\n * TEST: float rounding error needs more testing\n *\n * @param arr\n * @returns\n */\nexport const accumulate = (arr: number[], precision = 4) => {\n  const result = [];\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum = sum + arr[i];\n    result.push(sum);\n  }\n  return result.map((val) => roundF(val, precision));\n};\n\n/**\n * add to array in-place while limiting how many to keep history.\n *\n * \"first\" will insert at beginning of array.\n * @param arr array to keep history\n * @param entry value to add to history\n * @param newArrayLen how many elements to keep\n * @param mode insert where? \"first\" (default) | \"last\"\n * @returns updated array\n */\nexport const addToArray = <T>(\n  arr: T[],\n  entry: T,\n  newArrayLen: number,\n  mode: \"first\" | \"last\" = \"first\"\n) => {\n  // add\n  if (mode === \"first\") arr.unshift(entry); // add new one to beginning\n  else if (mode === \"last\") arr.push(entry); // add new one to end\n  // remove\n  if (arr.length > newArrayLen) {\n    if (mode === \"first\") arr.pop(); // remove last (oldest)\n    else if (mode === \"last\") arr.shift(); // remove first (oldest)\n  }\n  return arr;\n};\n\n/**\n * create a new array with given length and maps values\n * @param n length of generated array\n * @param fn callback function that goes into map(fn)\n * @returns new array with mapped values\n */\nexport const fillAndMap = <T>(\n  n: number,\n  fn: (el: null, idx: number) => T\n): T[] => {\n  if (n > 0) {\n    return Array(n).fill(null).map(fn);\n  }\n  throw new Error(\"fillAndMap(): n must be greater than zero\");\n};\n\n/**\n * check for elements with non-zero value and return indices\n * @param arr array to evaluate\n * @returns array of indices with non-zero values\n */\nexport const getNonZeroIndices = (arr: number[]): number[] => {\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] !== 0) result.push(i);\n  }\n  return result;\n};\n\n/**\n * interpolates between two 1d array of any size. for now, numbers only.\n *\n * TODO:\n * - expand to take object, nested aray/ojbects. recursive.\n * @param arrStart array to start from\n * @param arrTarget array to interpolate to\n * @param t 0..1\n * @returns 1d array\n */\nexport const interpolateArray = (\n  arrStart: number[],\n  arrTarget: number[],\n  t: number\n) => {\n  if (arrStart.length === 0 || arrTarget.length === 0)\n    throw new Error(\"interpolateArray(): arrays cannot be empty\");\n  if (arrStart.length !== arrTarget.length)\n    throw new Error(\"interpolateArray(): length must be same\");\n  return Array(arrStart.length)\n    .fill(0)\n    .map((_, i) => {\n      return mix(arrStart[i], arrTarget[i], t);\n    });\n};\n\n/**\n * check if all values of array is one.\n * @param arr array to evaluate\n * @returns true if all values are one\n */\nexport const isAllOne = (arr: number[]) => arr.every((el) => el === 1);\n\n/**\n * check if all values of array is zero.\n * @param arr array to evaluate\n * @returns true if all values are zero\n */\nexport const isAllZero = (arr: number[]) => arr.every((el) => el === 0);\n\n/**\n * check if any value of array is one\n * @param arr array to evaluate\n * @returns true if any value is one.\n */\nexport const isAnyOne = (arr: number[]) => arr.some((el) => el === 1);\n\n/**\n * check if any value of array is zero\n * @param arr array to evaluate\n * @returns true if any value is zero.\n */\nexport const isAnyZero = (arr: number[]) => arr.some((el) => el === 0);\n\n/**\n * convert object key:value pairs into simple array of values\n * @param obj\n * @param keys array of string keys. order is preserved.\n * @returns\n */\nexport const objectToArray = <T>(obj: { [key: string]: T }, keys: string[]) => {\n  return keys.map((key) => obj[key]);\n};\n\n/**\n * helper function to get object values inside an array. all objects must have same keys present.\n *\n * ex. [{name: val1},{name: val2}] => fn(arr, \"name\") => [val1, val2]\n * @param arr array of objects\n * @param objKey key string of object inside source array\n * @returns array\n */\nexport const unwrapArrayOfObjects = <T>(\n  arr: { [key: string]: T }[],\n  objKey: string\n) => {\n  return Array(arr.length)\n    .fill(null)\n    .map((_, i) => {\n      if (arr[i][objKey] !== undefined) {\n        return arr[i][objKey];\n      } else {\n        throw new Error(\n          \"unwrapArrayOfObjects(): all objects must have keys present\"\n        );\n      }\n    });\n};\n"]}